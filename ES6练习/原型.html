<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //这个Star函数实际上是一个构造函数
        function Star(uname, age) {
            this.uname = uname;
            this.age = age;
        }
        Star.age = 30; //静态属性 函数对象声明完后就会开辟出一个内存空间 所以无法被继承 其他实例无法访问
        console.log(Star.age);
        console.log(ldh);
        console.log(Star.prototype); //Javascript规定，每一个函数都有一个prototype对象属性，指向另一个对象（原型链上面的）prototype里面有个构造函数指向Star函数本身
        // prototype(对象属性)的所有属性和方法，都会被构造函数的实例继承。
        // 这意味着，我们可以把那些不变(公用)的属性和方法，直接定义在prototype对象属性上。
        // prototype就是调用构造函数所创建的那个实例对象的原型（proto）。
        // prototype可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中
        console.dir(Star);
        //具体见博客吧 我写好了!
        Star.prototype.sing = function () {
            console.log('我会唱歌');
        }
        //如果你直接使用如下方式
        // Star.prototype = {
        //     sing: function () {
        //         console.log('唱歌');
        //     }
        // }  切记 = 号是赋值操作 会覆盖原来里面的所有内容! 当然你也可以加: constructor:Star 重新指回原来的函数
        var ldh = new Star('刘德华', 50);
        ldh.sing()
        console.log(ldh.__proto__ === Star.prototype); //ture
        // 如果ldh本身有sing这个方法就执行, 否则就有__proto__去构造函数的原型对象上去找sing这个方法
        console.log(ldh.toString()); //前一个是对象Object 后一个是类型
    </script>
</body>

</html>