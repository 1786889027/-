<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>2</li>
        <li>2</li>
        <li>2</li>
    </ul>
    <script>
        // fun.call(thisArg,arg1,arg2,arg3...) call方法使用 第一个是当前调用函数this的指向对象
        // 最经典的 由于lis 本身没有forEach方法 ,通过一个空数组调出这个方法,然后改变他的指向从而达到遍历的目的
        var lis = document.querySelectorAll('li');
        [].forEach.call(lis, (li) => {
            console.log(li);
        })
        // 还有就是用call方法实现继承!ES6的类底层实现应该也是这个
        function Father(uname, age) {
            this.uname = uname;
            this.age = age;
        }

        function Son(uname, age) {
            Father.call(this, uname, age);
        }
        // 方法继承
        Father.prototype.sing = function () {
            console.log('唱歌');
        }
        //这样就实现了继承 
        // Son.prototype = Father.prototype
        // var son = new Son('薛之谦', 35)
        // son.sing()
        //但是我们如果往子类构造函数中添加方法时,父构造函数也会同步添加
        // Son.prototype.exam = function () {
        //     console.log('我要考试');
        // }
        // console.log(Father.prototype); 可以看到他也有exam方法
        //由此可见 此处的 = 是一种类似浅拷贝只是将Son.prototype对象的地址指向了父亲的prototype的地址
        // 以上不可靠 正确如下
        Son.prototype = new Father() //开辟一个新的实例 内存空间
        // 以上代码是将Son.prototype对象指向Father的实例对象,通过这个实例对象的__proto__访问Father的prototype对象实现继承
        var son = new Son('薛之谦', 35)
        Son.prototype.exam = function () {
            console.log('我要考试');
        }
        son.sing()
        console.log(Father.prototype); //这样里面就没有子类的方法了
    </script>

</body>

</html>