<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //浅拷贝只会拷贝一层 ，更深层次对象级别得只拷贝引用
        //深拷贝拷贝多层 每一级别都会拷贝
        var obj = {
            id: 1,
            name: 'andy',
            msg: {
                age: 18
            }
        }
        var o = {}
        var o1 = {}
        // for (var k in obj) {
        //     //k是属性名称 obj[k]是属性值
        //     o[k] = obj[k];
        // }
        // console.log(o);
        // //o的最里面的msg和obj的msg地址一样 是
        // console.log(o.msg === obj.msg); //true
        // es6浅拷贝方法 Object.assign(target,...sources) 
        console.log('------------');
        Object.assign(o, obj);
        console.log(o);
        console.log(o.msg === obj.msg); //true
        //封装函数 深拷贝

        function deepCopy(target, sources) {
            for (var k in sources) {
                //k是属性名称 obj[k]是属性值
                //判断属性的属性类型
                // 判断是否是数组
                let item = sources[k]
                if (item instanceof Array) {
                    target[k] = [];
                    deepCopy(target[k], item)
                }
                //判断是否是对象
                //小细节 数组写在Object上面 因为数组也是Object的一种
                else if (item instanceof Object) {
                    target[k] = {}
                    deepCopy(target[k], item)
                }
                //判断简单数据类型
                else {
                    target[k] = sources[k]
                }
            }
        }

        function JsonCopy(target, src) {
            let obj = JSON.stringify(src)
            console.log(obj);
            target = JSON.parse(obj)
            console.log(target); //拷贝后的对象
        }

        console.log(typeof deepCopy);
        JsonCopy(o1, obj)
        console.log(o1); //空对象  
        // ??为什么呢?  因为JsonCopy中 JSON.parse(obj) 生成了一个新的对象地址
        // javascript是值传递 先将target = o1(o1的地址给target)  而target = JSON.parse(obj)之后 是将这个新对象的地址给了target 而o1没有变化 依旧指向原来的空对象
        console.log(o1.msg === obj.msg); //false
    </script>
</body>

</html>