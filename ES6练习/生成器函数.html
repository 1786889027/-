<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //生成器其实就是一个特殊的函数
        //异步编程 以前纯回调函数 node.js  ajax 等都是异步的
        function* gen() {
            console.log('hello generator');
        }
        let iterator = gen()
        console.log(iterator); // 其实返回可以看作一个迭代器对象
        iterator.next()
        // 1.yield是ES6的新关键字，使生成器函数执行暂停，yield关键字后面的表达式的值返回给生成器的调用者。
        // 它可以被认为是一个基于生成器的版本的return关键字。
        // 2.yield关键字实际返回一个IteratorResult（迭代器）对象，它有两个属性，value和done，分别代表返回值和是否完成。
        // yield无法单独工作，需要配合generator(生成器)的其他函数，如next，懒汉式操作，展现强大的主动控制特性。
        function* gen2() {
            // console.log('111');
            yield '一只没有耳朵'
            // console.log('222');
            yield '一只没有尾巴'
            // console.log('333');
            yield '真奇怪'
            // console.log('444');
        }
        let iterator2 = gen2()
        console.log(iterator2.next());
        console.log(iterator2.next());
        console.log(iterator2.next());
        console.log(iterator2.next());
        //可见此函数是通过迭代器的next方法控制函数向下执行的 

        function* gen3(args) {
            console.log(args);
            let one = yield 111
            console.log(one);
            let two = yield 222
            console.log(two);
            let three = yield 333
            console.log(three);
        }
        let iterator3 = gen3('AAA')
        // next方法可以传入参数
        console.log(iterator3.next());
        console.log(iterator3.next('BBB')); //next传入的参数将作为上一个yiel语句的返回结果
        console.log(iterator3.next('CCC'));
        console.log(iterator3.next('DDD'));

        //异步编程实例
        // 先来看看回调地狱 无限回调
        // setTimeout(() => {
        //     console.log(111);
        //     setTimeout(() => {
        //         console.log(222);
        //         setTimeout(() => {
        //             console.log(333);
        //         }, 3000);
        //     }, 2000);
        // }, 1000);
        function one() {
            setTimeout(() => {
                console.log(111);
                iterator4.next()
            }, 1000);
        }

        function two() {
            setTimeout(() => {
                console.log(222);
                iterator4.next()
            }, 2000);
        }

        function three() {
            setTimeout(() => {
                console.log(333);
                iterator4.next()
            }, 3000);
        }

        function* gen4() {
            yield one()
            yield two()
            yield three()
        }
        let iterator4 = gen4()
        iterator4.next() //但是这样只执行了第一个one() 解决方案 每个函数后面加一句iterator4.next()

        //模拟获取 用户数据 订单数据 商品数据
        function getUsers() {
            setTimeout(() => {
                let data = '用户数据'
                iterator5.next(data) //这是第二次
            }, 1000);
        }

        function getOrders() {
            setTimeout(() => {
                let data = '订单数据'
                iterator5.next(data) //第三次
            }, 1000);
        }

        function getGoods() {
            setTimeout(() => {
                let data = '商品数据'
                iterator5.next(data) //第四次
            }, 1000);
        }

        function* gen5() {
            let users = yield getUsers()
            console.log(users);
            let orders = yield getOrders()
            console.log(orders);
            let goods = yield getGoods()
            console.log(goods);
        }
        let iterator5 = gen5()
        iterator5.next() //直接这样无法得到结果 因为数据无法处理 解决方案 每次next 把上次的数据当成参数传入 这是第一次调next
    </script>
</body>

</html>