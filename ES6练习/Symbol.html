<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

    <script>
        //创建symbol symbol相当于一个唯一标识
        let a = Symbol(); //强制创建一个新的
        console.log(a, typeof a);
        let s = Symbol('张三')
        let s2 = Symbol('张三')
        console.log(s === s2); //不一样  false 相当于编号不一样
        let s3 = Symbol.for('张三')
        let s4 = Symbol.for('张三') //用for创建的symbol 如果已经创建了一个相同的 那么就直接返回这个相同的
        console.log(s3 === s4); //true 
        console.log(Symbol.keyFor(s4)); //这个方法参数是一个通过Symbol.for()创建的symbol类型变量，返回这个symbol变量的描述信息。
        //Symbol不能与其他任何数据进行运算和对比
        //         4.对还有属性为Symbol的对象进行遍历

        // 　　　　若属性为Symbol类型，则该属性不会出现在for...in、for...of中，也不会通过使用Object.keys()、Object.getOwnPropertyName()得到，
        // 若想要得到，则需要使用Object.getOwnPropertySymbol()
        let youxi = {
            name: '狼人杀',
            [Symbol('say')]: function () { //对象中要这样声明Symbol
                console.log('我可以说话');
            },
            [Symbol('zibao')]: function () {
                console.log('我不玩了');
            }
        }
        let s5 = Symbol("jyy");
        console.log(String(s5)); // "Symbol(jyy)"
        console.log(s5.toString()); // "Symbol(jyy)"
        // console.log("" + s5); // 报错TypeError: Cannot convert a Symbol value to a string
        //可以看出String() 和toString() 方法是可以转为字符串的， 但是不可使用“” + Symbol() 转化， 回报类型错误

        // b.转换为布尔值

        let name = Symbol("jyy");
        console.log(Boolean(name)); // true
        if (name) {
            console.log(true); // 为true
        } else {
            console.log(false);
        }

        class Person {
            static[Symbol.hasInstance]() { //这个属性只想一个内部方法，当该对象使用instanceof时，会调用这个方法，代码如下
                console.log('我被用来检测类型了');
            };
            [Symbol.match](num) {
                return parseInt(num) > 100; // 自定义方法内的逻辑
            };
            [Symbol.replace](obj, rst) { // 两个参数，第一个是对象，第二个是返回的结果
                console.log(rst); // wss
                return "hello"; // 自定义返回值
            };
        }
        let o = {}
        console.log(o instanceof Person); //false 我被用来检测类型来  会自动调用!

        //Symbol.isConcatSpreadable 表示对象是否可以在Array.prototype.concat时可以展开
        let arr = [1, 2, 3];
        let arr1 = [4, 5];
        console.log(arr1[Symbol.isConcatSpreadable]); // undefined
        console.log(arr.concat(arr1)); // [ 1, 2, 3, 4, 5 ], 数组的Symbol.isConcatSpreadable默认为undefined,可以展开（true更可以）
        arr1[Symbol.isConcatSpreadable] = false;
        console.log(arr.concat(
            arr1)); // [ 1, 2, 3, [ 4, 5, [Symbol(Symbol.isConcatSpreadable)]: false ] ]  设置为false后不可展开
        // Symbol.match
        console.log("123".match(new Person())); // true  也是自动调用里面的match方法
        console.log("12".match(new Person())); // false
        console.log("jyy".replace(new Person(), "wss")); // hello 

        let obj2 = {
            [Symbol.toStringTag]: "Person" //用来自定义此对象转化后的toString值 
        }
        let b = {
            name: 'str'
        }
        console.log(obj2.toString()); //[object Person]
        console.log(b.toString()); //普通的[object Object]
    </script>
</body>

</html>